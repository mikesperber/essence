; Essential LR parsing in direct style
; ====================================

(loadt "../common/util.adt")
(loadt "../common/grammar.adt")
(loadt "../common/stream.adt")

;;; step 1: plain parser
;;; step 2: attribute evaluation
;;; step 3: imperative features

(defprim (my-list-tail l k) (list-tail l k))

;;; primitives

(defprim-opaque (allocate-variables)
  (eval '(begin (define parser-inp)
		(define parser-lhs)
		(define parser-att))
	(interaction-environment)))

(defprim-opaque (readvar-lhs) parser-lhs)
(defprim-opaque (readvar-att) parser-att)

(defprim-opaque (set-lhs! val) (set! parser-lhs val))
(defprim-opaque (set-att! val) (set! parser-att val))

(defprim-opaque (input-initialize! input) (set! parser-inp input))
(defprim-opaque (input-advance!) (set! parser-inp (stream-cdr parser-inp)))
(defprim-opaque (input-lookahead k)
  (let loop ((input parser-inp) (i 0))
    (cond
     ((= i k) (stream-car input))
     (else (loop (stream-cdr input) (+ i 1))))))

;;; handle attribute stack

(define (empty-stack) '())
(define (push elem stack)
  (cons elem stack))
(define (top->mylist n stack)
  (cond
   ((zero? n) (mynil))
   ((= n 1) (mycons (car stack) (mynil)))
   (else (mycons (car stack) (top->mylist (- n 1) (cdr stack))))))
(define (reverse-mylist xs)
  (let loop ((xs xs) (acc (mynil)))
    (if (mynil? xs)
	acc
	(loop (mycdr xs) (mycons (mycar xs) acc)))))
(define (my-list->list l)
  (if (mynil? l)
      '()
      (cons (mycar l)
	    (my-list->list (mycdr l)))))

;;; handle input
(define (input-char p) (car p))
(define (input-attr p) (cdr p))

;;; utilities

(define (filter-2 pred? list)
  (filter-20 pred? list '()))
(define (filter-20 pred? rest result)
  (if (null? rest)
      (reverse result)
      (filter-20 pred?
		 (cdr rest)
		 (if (pred? (car rest))
		     (cons (car rest) result)
		     result))))

;; the trick need be applied to all calls of parse-bar!

(define (direct-parse grammar type k first-map follow-map state
		      attribute-stack)


  ;; body of direct-parse

  (if (and (final? state grammar)
	   (equal? '$ (input-char (input-lookahead 0))))
      (car attribute-stack)
      (let* ((kk (if (equal? type 'LR) k 0))
	     (closure (compute-closure state grammar kk first-map))
	     (ts (next-terminals closure grammar))
	     (ts (sort-terminals ts))
	     (ts (if (final? state grammar)
		     (filter-2 (lambda (t) (not (equal? t '$))) ts)
		     ts))
	     (add-lookahead (if (equal? type 'LR)
				(lambda (x) x)
				(lambda (x) (add-slr-lookahead x follow-map))))
	     (accept-items (add-lookahead (accept closure))))

;;; local definitions

  (define (select-lookahead-item item-set k)
    (let loop ((trie (items->trie item-set k)) (pos 0))
      (if (null? trie)
	  (continue #f)
	  (if (= pos k)
	      (continue trie)
	      (let ((ch (input-char (input-lookahead pos))))
		(let inner-loop ((trie trie))
		  (if (null? trie)
		      (continue #f)
		      (if (let loop ((la-set (caar trie)))
			    (or (equal? ch (car la-set))
				(if (null? (cdr la-set))
				    #f
				    (loop (cdr la-set)))))
			  (loop (cdar trie)
				(+ pos 1))
			  (inner-loop (cdr trie))))))))))

  (define (continue production)
    (if (not production)
	;; shift-terminal
	(shift-terminal)
	(let* ((rhs-length (length (production-rhs production)))
	       (lhs (production-lhs production))
	       (attribution (production-attribution production))
	       (attribute-value (apply-attribution
				 attribution
				 (my-list->list
				  (reverse-mylist
				   (top->mylist rhs-length attribute-stack))))))
	  
	  ;; reduce, then shift on lhs
	  (if (zero? rhs-length)
	      ;; shift-nonterminal
	      (parse-bar grammar type k first-map follow-map closure lhs
			 attribute-value attribute-stack)
	      (begin (set-lhs! lhs) (set-att! attribute-value)
		     rhs-length)))))

  (define (shift-terminal)
    (let* ((p (input-lookahead 0))
	   (ch (input-char p))
	   (process (lambda (t)
		      (input-advance!)
		      (parse-bar grammar type k first-map follow-map closure t
				 (input-attr p) attribute-stack)))
	   (signal-error (lambda () (_sim-error 'direct-parse "can't shift on" ch))))
      (let loop ((ts ts))
	(if (null? ts)
	    (signal-error)
	    (let ((l (length ts)))
	      (if (= l 1)
		  (if (equal? (car ts) ch)
		      (process (car ts))
		      (signal-error))
		  (let* ((m (- (quotient l 2) 1))
			 (t (list-ref ts m)))
		    (if (= m 0)
			(cond
			 ((equal? t ch) (process t))
			 ((equal? (cadr ts) ch) (process (cadr ts)))
			 (else (signal-error)))
			(if (equal? t ch)
			    (process t)
			    (if (terminal<=? ch t)
				(loop (take m ts))
				(loop (my-list-tail ts (+ m 1)))))))))))))

;;; body of let*
	
	(if (null? accept-items)
	    ;; shift-terminal
	    (shift-terminal)
	    (select-lookahead-item accept-items k)))))

(define (parse-bar grammar type k first-map follow-map closure sym
		   attribute-value attribute-stack)
  (let* ((next-state (goto closure sym))
	 (result (direct-parse grammar type k first-map follow-map next-state
			       (push attribute-value attribute-stack))))
    (if (final? next-state grammar)
	result
	(let* ((nts (sort-nonterminals (next-nonterminals closure grammar)))
	       (the-dot result))
	  (if (null? nts)
	      (- the-dot 1)
	      (if (< 1 the-dot)
		  (- the-dot 1)
		  (let* ((the-lhs (readvar-lhs))
			 (the-att (readvar-att)))
		    ;; as written, it needs *always* log_2 |nts| comparisons
		    (let loop ((nts nts))
		      (let* ((l (length nts)))
			(if (= l 1)
			    (parse-bar grammar type k first-map follow-map closure (car nts)
				       the-att attribute-stack)
			    (let ((m (- (quotient l 2) 1)))
			      (if (>= (list-ref nts m) the-lhs)
				  (if (= m 0)
				      (parse-bar grammar type k first-map follow-map closure (car nts)
						 the-att attribute-stack)
				      (loop (take (+ m 1) nts)))
				  (loop (my-list-tail nts (+ m 1)))))))))))))))

(define (direct-parse-main source-grammar type k input)
  (let* ((grammar (source-grammar->grammar source-grammar k))
	 (start-production (car (grammar-productions grammar))))
    (allocate-variables)
    (input-initialize! input)
    (cond
     ((equal? type 'LR)
      (direct-parse grammar
		    type
		    k
		    (compute-first grammar k)
		    #f
		    (list
		     (make-item start-production
				0
				(cdr (production-rhs start-production))))
		    '()))
     ((equal? type 'SLR)
      (let ((first-map (compute-first grammar k)))
	(direct-parse grammar
		      type
		      k
		      first-map
		      (compute-follow grammar k first-map)
		      (list
		       (make-item start-production
				  0
				  (cdr (production-rhs start-production))))
		      '()))))))


