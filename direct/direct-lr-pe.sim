; Essential LR parsing in direct style
; ====================================

(loadt "../common/util.adt")
(loadt "../common/grammar.adt")
(loadt "../common/stream.adt")

;;; step 1: plain parser
;;; step 2: attribute evaluation
;;; step 3: imperative features

(defprim (my-list-tail l k) (list-tail l k))

;;; primitives

(defprim-opaque (allocate-variables)
  (eval '(begin (define parser-inp)
		(define parser-lhs)
		(define parser-att))
	(interaction-environment)))

(defprim-opaque (readvar-lhs) parser-lhs)
(defprim-opaque (readvar-att) parser-att)

(defprim-opaque (set-lhs! val) (set! parser-lhs val))
(defprim-opaque (set-att! val) (set! parser-att val))

(defprim-opaque (input-initialize! input) (set! parser-inp input))
(defprim-opaque (input-advance!) (set! parser-inp (stream-cdr parser-inp)))
(defprim-opaque (input-lookahead k)
  (let loop ((input parser-inp) (i 0))
    (cond
     ((= i k) (stream-car input))
     (else (loop (stream-cdr input) (+ i 1))))))

;;; handle attribute stack

(define (empty-stack) '())
(define (push elem stack)
  (cons elem stack))
(define (top->mylist n stack)
  (cond
   ((zero? n) (mynil))
   ((= n 1) (mycons (car stack) (mynil)))
   (else (mycons (car stack) (top->mylist (- n 1) (cdr stack))))))
(define (reverse-mylist xs)
  (let loop ((xs xs) (acc (mynil)))
    (if (mynil? xs)
	acc
	(loop (mycdr xs) (mycons (mycar xs) acc)))))
(define (my-list->list l)
  (if (mynil? l)
      '()
      (cons (mycar l)
	    (my-list->list (mycdr l)))))

;;; handle input
(define (input-char p) (car p))
(define (input-attr p) (cdr p))

;;; utilities

(define (filter-2 pred? list)
  (filter-20 pred? list '()))
(define (filter-20 pred? rest result)
  (if (null? rest)
      (reverse result)
      (filter-20 pred?
		 (cdr rest)
		 (if (pred? (car rest))
		     (cons (car rest) result)
		     result))))

;; the trick need be applied to all calls of parse-bar!

(define (direct-parse grammar k first-map state
		      attribute-stack)



  ;; body of direct-parse

  (if (and (final? state grammar)
	   (equal? '$ (input-char (input-lookahead 0))))
      (car attribute-stack)
      (let* ((closure (compute-closure state grammar k first-map))
	     (ts (next-terminals closure grammar))
	     (ts (if (final? state grammar)
		     (filter-2 (lambda (t) (not (equal? t '$))) ts)
		     ts))
	     (accept-items (accept closure)))

;;; local definitions

  (define (select-lookahead-item item-set k)
    (let loop ((trie (items->trie item-set k)) (pos 0))
      (if (null? trie)
	  (continue #f)
	  (if (= pos k)
	      (continue trie)
	      (let ((ch (input-lookahead pos)))
		(let inner-loop ((trie trie))
		  (if (null? trie)
		      (continue #f)
		      (if (let loop ((la-set (caar trie)))
			    (or (equal? ch (car la-set))
				(if (null? (cdr la-set))
				    #f
				    (loop (cdr la-set)))))
			  (loop (cdar trie)
				(+ pos 1))
			  (inner-loop (cdr trie))))))))))

  (define (continue production)
    (if (not production)
	;; shift-terminal
	(let* ((p (input-lookahead 0))
	       (ch (input-char p)))
	  (let loop ((ts ts))
	    (if (null? ts)
		(_sim-error 'direct-parse "can't shift on" ch)
		(if (equal? (car ts) ch)
		    (begin
		      (input-advance!)
		      (parse-bar grammar k first-map closure (car ts)
				 (input-attr p) attribute-stack))
		    (loop (cdr ts))))))
	(let* ((rhs-length (length (production-rhs production)))
	       (lhs (production-lhs production))
	       (attribution (production-attribution production))
	       (attribute-value (apply-attribution
				 attribution
				 (my-list->list
				  (reverse-mylist
				   (top->mylist rhs-length attribute-stack))))))
	  
	  ;; reduce, then shift on lhs
	  (if (zero? rhs-length)
	      ;; shift-nonterminal
	      (parse-bar grammar k first-map closure lhs
			 attribute-value attribute-stack)
	      (begin (set-lhs! lhs) (set-att! attribute-value)
		     rhs-length)))))

;;; body of let*
	
	(if (null? accept-items)
	    ;; shift-terminal
	    (let* ((p (input-lookahead 0))
		   (ch (input-char p)))
	      (let loop ((ts ts))
		(if (null? ts)
		    (_sim-error 'direct-parse "can't shift on" ch)
		    (if (equal? (car ts) ch)
			(begin
			  (input-advance!)
			  (parse-bar grammar k first-map closure (car ts)
				     (input-attr p) attribute-stack))
			(loop (cdr ts))))))
	    (select-lookahead-item accept-items k)))))

(define (parse-bar grammar k first-map closure sym
		   attribute-value attribute-stack)
  (let* ((next-state (goto closure sym))
	 (result (direct-parse grammar k first-map next-state
			       (push attribute-value attribute-stack))))
    (if (final? next-state grammar)
	result
	(let* ((nts (next-nonterminals closure grammar))
	       (the-dot result))
	  (if (null? nts)
	      (- the-dot 1)
	      (if (< 1 the-dot)
		  (- the-dot 1)
		  (let* ((the-lhs (readvar-lhs))
			 (the-att (readvar-att)))
	      (let loop ((nts nts))
		(if (null? (cdr nts))
		    (parse-bar grammar k first-map closure (car nts)
			       the-att attribute-stack)
		    (if (equal? (car nts) the-lhs)
			(parse-bar grammar k first-map closure (car nts)
				   the-att attribute-stack)
			(loop (cdr nts))))))))))))

(define (direct-parse-main source-grammar k input)
  (let* ((grammar (source-grammar->grammar source-grammar k))
	 (start-production (car (grammar-productions grammar))))
    (allocate-variables)
    (input-initialize! input)
    (direct-parse grammar
		  k
		  (compute-first grammar k)
		  (list
		   (make-item start-production
			      0
			      (cdr (production-rhs start-production))))
		  '())))


