; Essential LR parsing
; ====================

(loadt "../common/util.adt")
(loadt "../common/grammar.adt")
(loadt "../common/stream.adt")

; General utility functions
; ~~~~~~~~~~~~~~~~~~~~~~~~~

(define (generalize1 z)
  (if #t z (generalize z)))
 
(define (filter-2 pred? list)
  (let loop ((rest list) (result '()))
    (if (null? rest)
	(reverse result)
	(loop (cdr rest)
	      (if (pred? (car rest))
		  (cons (car rest) result)
		  result)))))

(define (my-take n inl)
  (cond ((zero? n) (mynil))
	((= n 1) (mycons (mycar inl) (mynil)))
	(else
	 (mycons (mycar inl) (my-take (- n 1) (mycdr inl))))))

(define (my-drop n lst)
  (if (zero? n)
      lst
      (my-drop (- n 1) (mycdr lst))))

(define (my-list-ref l n)
  (mycar (my-drop n l)))

(define (my-reverse l)
  (let loop ((l l) (r (mynil)))
    (if (mynil? l)
	r
	(loop (mycdr l)
	      (mycons (mycar l) r)))))

(define (my-list->list l)
  (if (mynil? l)
      '()
      (cons (mycar l)
	    (my-list->list (mycdr l)))))

; The real McCoy
; ~~~~~~~~~~~~~~

(define (goto-cps state-closure symbol symbols c)
  (and (not (null? symbols))
       (let loop ((s symbols))
	 (if (null? (cdr s))
	     (c (goto state-closure (car s)))
	     (if (equal? (car s) symbol)
		 (c (goto state-closure (car s)))
		 (loop (cdr s)))))))

(define (select-lookahead-item-cps item-set k input c)
  (let loop ((item-set item-set)
	     (pos 0)
	     (input input))
    (if (= pos k)
	(c (if (null? item-set) #f (car item-set)))
	(if (null? item-set)
	    (c #f)
	    (let ((t (car (stream-car input))))
	      (let loop-2 ((items item-set)
			   (used-lookaheads '()))
		(if (null? items)
		    (c #f)
		    (let* ((item (car items))
			   (kth-lookahead (list-ref (item-lookahead item) pos)))
		      (if (member kth-lookahead used-lookaheads)
			  (loop-2 (cdr items) used-lookaheads)
			  (if (equal? t kth-lookahead)
			      (loop (filter-2 (lambda (item)
						(equal?
						 (list-ref (item-lookahead item) pos)
						 kth-lookahead))
					      item-set)
				    (+ pos 1)
				    (if (= (+ 1 pos) k)
					'() ; so as to not touch (stream-cdr input)
					(stream-cdr input)))
			      (loop-2 (cdr items) (cons kth-lookahead used-lookaheads))))))))))))

(define (handle-conflict! name item-1 item-2)
  (_sim-display-immediate name)
  (_sim-display-immediate " conflict in state ")
  (_sim-write-immediate closure)
  (_sim-newline-immediate)
  (_sim-display-immediate "(items ")
  (_sim-write-immediate item-1)
  (_sim-display-immediate " and ")
  (_sim-write-immediate item-2))

(define (find-lookahead la items)
  (let loop ((items items))
    (and (not (null? items))
	 (if (equal? (item-lookahead (car items)) la)
	     (car items)
	     (loop (cdr items))))))

(define (check-for-conflict! grammar first-map closure accept-items k)
  ;; check for reduce-reduce conflict
  (let loop ((item-set accept-items))
    (and (not (null? item-set))
	 (let ((la-item (find-lookahead (item-lookahead (car item-set))
					(cdr item-set))))
	   (if la-item
	       (handle-conflict! "Reduce-reduce" la-item (car item-set))
	       (loop (cdr item-set))))))
  ;; check for shift-reduce conflict
  (let loop ((items closure))
    (and (not (null? items))
	 (if (null? (item-rhs-rest (car items)))
	     (loop (cdr items))
	     (let inner-loop ((fs (sf-first
				   (append-k k
					     (item-rhs-rest (car items))
					     (item-lookahead (car items)))
				   k grammar first-map)))
	       (if (null? fs)
		   (loop (cdr items))
		   (let ((la-item (find-lookahead (car fs) accept-items)))
		     (if la-item
			 (handle-conflict! "Shift-reduce" (car items) la-item)
			 (inner-loop (cdr fs))))))))))

(define (cps-parse grammar k first-map state
		   continuations attribute-values
		   error error-status input)

  (if (and (final? state grammar)
	   (equal? '$ (car (stream-car input))))
      (if (mynil? attribute-values)
	  (_sim-error 'cps-parse "This can't happen.")
	  (mycar attribute-values))
      (let* ((closure (compute-closure state grammar k first-map))
	     (accept-items (accept closure)))

	(define (error-here input error-status)

	  (let* ((state (goto closure '@error@))
		 (n-active (- (active state) 1))
		 (closure (compute-closure state grammar k first-map))
		 (accept-items (accept closure))
		 (shift-terminals (next-terminals closure grammar))
		 (attribute-value (car (stream-car input))))

	    (define (recover input)
	      (display "Recovering ...") (newline)
	      (cps-parse grammar k first-map
			 state
			 (mycons (generalize1 c0)
				 (my-take n-active continuations))
			 (mycons attribute-value
				 (my-take n-active attribute-values))
			 error-here
			 3
			 input))

	    (define (maybe-recover-with-shift input t ts failure)
	      ;; (display ">>> maybe-recover-with-shift ") (write t) (display " ") (write ts) (newline)
	      (let loop ((ts ts))
		(if (null? ts)
		    (failure)
		    (if (equal? t (car ts))
			(recover input)
			(loop (cdr ts))))))

	    (define (maybe-recover-with-reduce input accept-items failure)
	      ;; (display ">>> maybe-recover-with-reduce ") (write accept-items) (newline)
	      (if (not (null? accept-items))
		  (select-lookahead-item-cps
		   accept-items k input
		   (lambda (item)
		     (if item
			 (recover input)
			 (failure))))
		  (failure)))

	    (let loop ((input (if (= 3 error-status)
				  ;; another error just happened
				  (stream-cdr input)
				  input)))
	      (let* ((p (stream-car input))
		     (t (car p)))

		(if (equal? '$ t)

		    (begin
		      (display "error recovery failed: unexpected EOF") (newline)
		      'parse-error)

		    (maybe-recover-with-shift
		     input t shift-terminals
		     (lambda ()
		       (maybe-recover-with-reduce
			input accept-items
			(lambda ()
			  ;; (display "Skipping ") (write (stream-car input)) (newline)
			  (loop (stream-cdr input)))))))))))

	(define (c0 symbol attribute-value input)
	  (goto-cps
	   closure symbol (next-nonterminals closure grammar)
	   (lambda (next-state)
	     (let ((n-active (- (active next-state) 1)))
	       (cps-parse grammar k first-map
			  next-state
			  (mycons (generalize1 c0)
				  (my-take n-active continuations))
			  (mycons attribute-value
				  (my-take n-active attribute-values))
			  (if (member '@error@ (next-terminals closure grammar))
			      error-here
			      error)
			  error-status
			  input)))))

	;; this is essentially c0 with symbol static
	(define (shift-nonterminal symbol attribute-value input)
	  (let* ((next-state (goto closure symbol))
		 (n-active (- (active next-state) 1)))
	    (cps-parse grammar k first-map
		       next-state
		       (mycons (generalize1 c0)
			       (my-take n-active continuations))
		       (mycons attribute-value
			       (my-take n-active attribute-values))
		       (if (member '@error@ (next-terminals closure grammar))
			   error-here
			   error)
		       error-status
		       input)))

	(define (shift-terminal token attribute-value)
	  (let ((nts (next-terminals closure grammar)))
	    (let loop ((ts nts))
	      (if (null? ts)
		  (begin
		    (display "parse error: expected one of ")
		    (write nts)
		    (display " or ")
		    (write (items-lookaheads accept-items))
		    (newline)
		    (error input error-status))
		  (if (equal? token (car ts))
		      (let* ((next-state (goto closure (car ts)))
			     (n-active (- (active next-state) 1)))
			(cps-parse grammar k first-map
				   next-state
				   (mycons (generalize1 c0)
					   (my-take n-active continuations))
				   (mycons attribute-value
					   (my-take n-active attribute-values))
				   (if (member '@error@ nts)
				       error-here
				       error)
				   (if (zero? error-status)
				       error-status
				       (- error-status 1))
				   (stream-cdr input)))
		      (loop (cdr ts)))))))


	(check-for-conflict! grammar first-map closure accept-items k)

	(if (null? accept-items)
	    (let* ((p (stream-car input)))
	      (shift-terminal (car p) (cdr p)))
	    (select-lookahead-item-cps
	     accept-items k input
	     (lambda (item)
	       (if (not item)
		   (let* ((p (stream-car input)))
		     (shift-terminal (car p) (cdr p)))
		   (let* ((rhs-length (length (item-rhs item)))
			  (attribution (production-attribution
					(item-production item)))
			  (attribute-value
			   (apply-attribution
			    attribution
			    (my-list->list
			     (my-reverse
			      (my-take rhs-length attribute-values))))))
					
		     ;; reduce, then shift on lhs
		     (if (zero? rhs-length)
			 (shift-nonterminal (item-lhs item) attribute-value input)
			 ((my-list-ref continuations (- rhs-length 1))
			  (item-lhs item)
			  attribute-value
			  input))))))))))

(define (cps-parse-main source-grammar k input)
  (let* ((grammar (source-grammar->grammar source-grammar k))
	 (start-production
	   (car (grammar-productions grammar))))
    (cps-parse grammar
	       k
	       (compute-first grammar k)
	       (list
		(make-item start-production
			   0
			   (cdr (production-rhs start-production))))
	       (mynil)
	       (mynil)
	       (lambda (input error-status)
		 (begin
		   (display "parse error: no recovery possible")
		   'parse-error))
	       0
	       input)))
