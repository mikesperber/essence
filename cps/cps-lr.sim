; Essential LR parsing
; ====================

(loadt "../common/util.adt")
(loadt "../common/grammar.adt")
(loadt "../common/stream.adt")

; General utility functions
; ~~~~~~~~~~~~~~~~~~~~~~~~~

(define (generalize1 z)
  (if #t z (generalize z)))

(define (eta-expand-3-d c)
  (lambda (x y z)
    (c x y z)))

(define (eta-expand-3-s c)
  (lambda (x y z)
    (c x y z)))

(define (collapse-3 c)
  (eta-expand-3-s (generalize1 (eta-expand-3-d c))))

; ---
 
(define (filter-2 pred? list)
  (let loop ((rest list) (result '()))
    (if (null? rest)
	(reverse result)
	(loop (cdr rest)
	      (if (pred? (car rest))
		  (cons (car rest) result)
		  result)))))

(define (my-take n inl)
  (cond ((zero? n) (mynil))
	((= n 1) (mycons (mycar inl) (mynil)))
	(else
	 (mycons (mycar inl) (my-take (- n 1) (mycdr inl))))))

(define (my-drop n lst)
  (if (zero? n)
      lst
      (my-drop (- n 1) (mycdr lst))))

(define (my-list-ref l n)
  (mycar (my-drop n l)))

(define (my-reverse l)
  (let loop ((l l) (r (mynil)))
    (if (mynil? l)
	r
	(loop (mycdr l)
	      (mycons (mycar l) r)))))

(define (my-list->list l)
  (if (mynil? l)
      '()
      (cons (mycar l)
	    (my-list->list (mycdr l)))))

; The real McCoy
; ~~~~~~~~~~~~~~

(define (goto-cps state-closure symbol grammar c)
  (let ((nonterm (next-nonterminals state-closure grammar)))
    (if (null? nonterm)
	#f
	(let loop ((s nonterm))
	  (if (null? (cdr s))
	      (c (goto state-closure (car s)))
	      (if (equal? (car s) symbol)
		  (c (goto state-closure (car s)))
		  (loop (cdr s))))))))

(define (cps-parse grammar k first-map state continuations attribute-values input)

  (if (and (final? state grammar)
	   (equal? '$ (car (stream-car input))))
      (if (mynil? attribute-values)
	  (_sim-error 'cps-parse "I didn't expect this!")
	  (mycar attribute-values))
      (let* ((closure (closure state grammar k first-map))
	     (accept-items (accept closure)))

	(define (c0 symbol attribute-value input)
	  (goto-cps
	   closure symbol grammar
	   (lambda (next-state)
	     (let ((n-active (- (active next-state) 1)))
	       (cps-parse grammar k first-map
			  next-state
			  (mycons (collapse-3 c0)
				  (my-take n-active continuations))
			  (mycons attribute-value
				  (my-take n-active attribute-values))
			  input)))))

	(define (shift-terminal token attribute-value)
	  (let loop ((ts (next-terminals closure grammar)))
	    (if (null? ts)
		(_sim-error 'cps-parse "Syntax Terror, call the bomb squad!")
		(if (equal? token (car ts))
		    (let* ((next-state (goto closure (car ts)))
			   (n-active (- (active next-state) 1)))
		      (cps-parse grammar k first-map
				 next-state
				 (mycons (collapse-3 c0)
					 (my-take n-active continuations))
				 (mycons attribute-value
					 (my-take n-active attribute-values))
				 (stream-cdr input)))
		    (loop (cdr ts))))))

	(define (shift-nonterminal s attribute-value)
	  (let loop ((ss (next-nonterminals closure grammar)))
	    (if (equal? s (car ss))
		(let* ((next-state (goto closure (car ss)))
		       (n-active (- (active next-state) 1)))
		  (cps-parse grammar k first-map
			     next-state
			     (mycons (collapse-3 c0)
				     (my-take n-active continuations))
			     (mycons attribute-value
				     (my-take n-active attribute-values))
			     input))
		(loop (cdr ss)))))

	(define (select-lookahead-item-cps item-set input c)
	  (let loop ((item-set item-set)
		     (pos 0)
		     (input input))
	    (if (= pos k)
		(c (if (null? item-set) #f (car item-set)))
		(if (null? item-set)
		    (c #f)
		    (let ((t (car (stream-car input))))
		      (let loop-2 ((items item-set)
				   (used-lookaheads '()))
			
			(if (null? items)
			    (c #f)
			    (let* ((item (car items))
				   (kth-lookahead (list-ref (item-lookahead item) pos)))
			      (if (member kth-lookahead used-lookaheads)
				  (loop-2 (cdr items) used-lookaheads)
				  (if (equal? t kth-lookahead)
				      (loop (filter-2 (lambda (item)
							(equal?
							 (list-ref (item-lookahead item) pos)
							 kth-lookahead))
						      item-set)
					    (+ pos 1)
					    (if (= (+ 1 pos) k)
						'() ; so as to not touch (stream-cdr input)
						(stream-cdr input)))
				      (loop-2 (cdr items) (cons kth-lookahead used-lookaheads))))))))))))
	    


	(define (handle-conflict! name item-1 item-2)
	  (_sim-display-immediate name)
	  (_sim-display-immediate " conflict in state ")
	  (_sim-write-immediate closure)
	  (_sim-newline-immediate)
	  (_sim-display-immediate "(items ")
	  (_sim-write-immediate item-1)
	  (_sim-display-immediate " and ")
	  (_sim-write-immediate item-2))

	(define (find-lookahead la items)
	  (let loop ((items items))
	    (if (null? items)
		#f
		(if (equal? (item-lookahead (car items)) la)
		    (car items)
		    (loop (cdr items))))))

	;; check for reduce-reduce conflict
	(let loop ((item-set accept-items))
	  (and (not (null? item-set))
	       (let ((la-item (find-lookahead (item-lookahead (car item-set))
					      (cdr item-set))))
		 (if la-item
		     (handle-conflict! "Reduce-reduce" la-item (car item-set))
		     (loop (cdr item-set))))))
	;; check for shift-reduce conflict
	(let loop ((items closure))
	  (and (not (null? items))
	       (if (null? (item-rhs-rest (car items)))
		  (loop (cdr items))
		  (let inner-loop ((fs (sf-first
					(append-k k
						  (item-rhs-rest (car items))
						  (item-lookahead (car items)))
					k grammar first-map)))
		    (if (null? fs)
			(loop (cdr items))
			(let ((la-item (find-lookahead (car fs) accept-items)))
			  (if la-item
			      (handle-conflict! "Shift-reduce" (car items) la-item)
			      (inner-loop (cdr fs)))))))))

	(if (null? accept-items)
	    (let* ((p (stream-car input)))
	      (shift-terminal (car p) (cdr p)))
	    (select-lookahead-item-cps
	     accept-items input
	     (lambda (item)
	       (if (not item)
		   (let* ((p (stream-car input)))
		     (shift-terminal (car p) (cdr p)))
		   (let* ((rhs-length (length (item-rhs item)))
			  (attribution (production-attribution
					(item-production item)))
			  (attribute-value
			   (apply-attribution
			    attribution
			    (my-list->list
			     (my-reverse
			      (my-take rhs-length attribute-values))))))
					
		     ;; reduce, then shift on lhs
		     (if (zero? rhs-length)
			 (shift-nonterminal (item-lhs item) attribute-value)
			 ((my-list-ref continuations (- rhs-length 1))
			  (item-lhs item)
			  attribute-value
			  input))))))))))

(define (cps-parse-main source-grammar k input)
  (let* ((grammar (source-grammar->grammar source-grammar k))
	 (start-production
	   (car (grammar-productions grammar))))
    (cps-parse grammar
	       k
	       (compute-first grammar k)
	       (list
		(make-item start-production
			   0
			   (cdr (production-rhs start-production))))
	       (mynil)
	       (mynil)
	       input)))
